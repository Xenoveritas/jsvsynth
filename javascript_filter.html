<!DOCTYPE html>

<html>
<head>
<title>AviSynth.Filter</title>
<link rel="stylesheet" type="text/css" href="bootstrap/css/bootstrap.min.css">
<link rel="stylesheet" type="text/css" href="bootstrap/css/bootstrap-theme.min.css">
</head>
<body>
<div class="container">
<h1 id="AviSynth_Filter">AviSynth.Filter</h1>
<p>The <code>AviSynth.Filter</code> class is used to create a JavaScript-based filter. At
present, you have to wrap an existing clip to use as a source filter. A future
version will allow you to write a filter that acts as a clip source.</p>
<p>Check out the <a href="api/AviSynth.Filter.html">complete API documentation</a> for
complete details.</p>
<p>The basic idea is that you replace the <code>getFrame</code> function with a custom
implementation:</p>
<pre><code>var filter = new AviSynth.Filter(avs.BlankClip());
filter.getFrame = function(frameNumber) {
    var frame = this.child.getFrame(frameNumber);
    var context = frame.getContext(&#39;simple&#39;);
    context.fillRect(0xFF0000FF, 10, 10, 20, 20);
    return frame;
};</code></pre>
<p>This draws a blue square on a black blank frame. You can actually do some fairly
complicated stuff with this since you can directly access the frame&#39;s pixel
data:</p>
<pre><code>var filter = new AviSynth.Filter(avs.Trim(avs.ColorBars(), 0, 240));
filter.getFrame = function(frameNumber) {
    var frame = this.child.getFrame(frameNumber);
    var w = frame.width, h = frame.height, pitch = frame.pitch/4;
    var data = new Uint32Array(frame.data);
    for (var y = 0; y &lt; h; y++) {
        for (var x = 0; x &lt; w; x++) {
            data[y*pitch+x] = data[y*pitch+x] ^ 0xFFFFFF;
        }
    }
    return frame;
};
filter;</code></pre>
<p>The above example will invert a frame by directly accessing the pixel data and
inverting each pixel. (Note that it actually inverts only the final three bytes,
leaving the alpha channel alone.)</p>
</div>
</body>
</html>
