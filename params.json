{"name":"Jsvsynth","tagline":"JSVSynth, a plugin allowing embedding JavaScript into AviSynth scripts.","body":"JSVSynth\r\n========\r\n\r\nJSVSynth is a plugin to AviSynth that allows the use of JavaScript within\r\nAviSynth scripts. It uses [Google's V8 JavaScript\r\nengine](https://developers.google.com/v8/) (the same JavaScript\r\nengine that Chrome uses) to run JavaScript. This means that the pure JavaScript\r\ncode will run with the same speed that Chrome's pure JavaScript does. (The\r\nscripting bridge provided by the plugin may not be quite as fast.)\r\n\r\nJSVSynth is licensed under the GPLv3. Note that, just like AviSynth being under\r\nthe GPL, this does not require scripts written using JSVSynth being released\r\nunder the GPLv3.\r\n\r\nUsing the Plugin\r\n----------------\r\n\r\nWith a compiled version of the plugin (see Building the Plugin below), using it\r\nfrom within AviSynth is fairly simple:\r\n\r\n    LoadPlugin(\"jsvsynth.dll\")\r\n\r\nYou can then use AviSynth's multi-line string blocks to write your actual\r\nJavaScript code:\r\n\r\n    JavaScript(\"\"\"\r\n    avisynth.Subtitle(avisynth.BlankClip({color:0xFF}), \"Hello from JavaScript!\")\r\n    \"\"\")\r\n\r\nThe JavaScript object `avisynth` offers access to any AviSynth variable or\r\nfunction from within JavaScript:\r\n\r\n    avsvalue = \"Set in AviSynth\"\r\n    JavaScript(\"\"\"\r\n    avisynth.Subtitle(avisynth.BlankClip({color:0xFF}), avisynth.avsvalue)\r\n    \"\"\")\r\n\r\nYou can almost do the reverse, but with one caveat:\r\n\r\n    avsvalue = 0\r\n    JavaScript(\"\"\"\r\n    avisynth.avsvalue = \"Hello \" + \"AviSynth!\";\r\n    \"\"\")\r\n    Subtitle(BlankClip(color=$FF), avsvalue);\r\n\r\nThe value has to be set to something before it will work. Otherwise, even though\r\nthe value will be set, AviSynth will give an \"I don't know what avsvalue means\"\r\nerror for the variable.\r\n\r\nI'm not entirely sure whether or not this is a problem with AviSynth or is\r\ninstead something I'm unclear about within the AviSynth API.\r\n\r\n### Calling AviSynth Filters from JavaScript\r\n\r\nFor the most part, this works like you'd expect: invoke a function using the\r\nexact same values you would in AviSynth. However, things work slightly\r\ndifferently when using JavaScript than they would in AviSynth.\r\n\r\n1. At present, it's not possible to do something like `clip.Trim(50)`. A future\r\n   update will likely attempt to make code like that possible.\r\n2. Named variables are handled as an object, as demonstrated by the\r\n   `avisynth.BlankClip({color:0xFF})` above. This value must always be the\r\n   **last** value given. Otherwise, it'll be translated into a string (likely\r\n   `[object Object]`).\r\n3. Conversions from JavaScript don't take into account the signature of the\r\n   function being called. (As the signature can't be retrieved by plugins\r\n   anyway.)\r\n4. `last` is not a thing in JavaScript. Calling a filter without specifying a\r\n   clip won't automatically cause `last` to be used.\r\n\r\n### Other Weird Caveats\r\n\r\nAviSynth is case insensitive, and the `avisynth` object will reflect that:\r\n\r\n`avisynth.blankclip()` is the same as `avisynth.BlankClip()`.\r\n\r\nJavaScript is not: `avisynth.blankclip()` is **not** the same as\r\n`AviSynth.blankclip()`!\r\n\r\nThis is one of the reasons why you can't use `for(var i in avisynth)` to iterate\r\nover variables in AviSynth. (The primary reason is that the AviSynth API offers\r\nabsolutely no way to pull the list of variables in any case.)\r\n\r\nAnother weird caveat is passing functions back to AviSynth. With most values,\r\nyou can actually use the evaluation of the JavaScript block:\r\n\r\n    Subtitle(BlankClip(), String(JavaScript(\"12 + 30\")))\r\n\r\nHowever, you can't pass functions back in this fashion, as this doesn't make\r\nsense in AviSynth: functions aren't \"variables\" per se, they're instead in a\r\nseparate (of sorts) namespace. (If you do write a bit of JavaScript that\r\nevaluates to a function, the result will be the function converted to a string.)\r\n\r\nThis doesn't mean you can't use JavaScript functions from AviSynth: you just\r\nhave to \"export\" them using the AviSynth object:\r\n\r\n    JavaScript(\"\"\"\r\n      avisynth.fromjs = function(str) {\r\n        return \"Hello \" + str.substring(0,1).toUpperCase() + str.substring(1);\r\n      }\r\n    \"\"\")\r\n    Subtitle(BlankClip(), FromJS(\"world\"))\r\n\r\nNote that (at present) there's no way to specify a function's signature or to\r\naccept named arguments from AviSynth (as those rely on a signature).\r\n\r\nAnother caveat with this is that using functions in this way will (potentially)\r\nleak memory: these functions are bound to the AviSynth environment and can\r\nnever be collected while the script runs. (I don't think this is any real\r\npractical concern, but it's worth noting somewhere.) Theoretically everything\r\nshould be collected when AviSynth shuts down, but I haven't verified this.\r\n\r\n### Animating With JavaScript\r\n\r\nIt may be tempting to write a JavaScript function within an AviSynth function\r\nand use that within `Animate`. **Don't do that.** The JavaScript function will\r\nbe recompiled every single frame and you won't get any of the speed advantages\r\nof V8's JIT.\r\n\r\nInstead, use the above method of exporting functions and animate that way:\r\n\r\n    JavaScript(\"\"\"\r\n      avisynth.animfun = function(clip, str, y) {\r\n        return avisynth.Subtitle(clip, str, {y:y});\r\n      }\r\n    \"\"\")\r\n    c = BlankClip()\r\n    Animate(0, 50, \"animfun\", c,\"Scrolling\",0, c,\"Scrolling\",50)\r\n\r\nBuilding the Plugin\r\n-------------------\r\n\r\nIn order to build this plugin, you'll require V8, which is not included. (At one\r\npoint I was hoping to include just the V8 binaries, but they're large enough and\r\nV8 is a fast enough moving target that it just isn't feasible.)\r\n\r\nIn any case, use SVN to download the V8 trunk into \"v8\":\r\n\r\n    svn http://v8.googlecode.com/svn/trunk v8\r\n\r\nNote that while using git is \"recommended,\" the git instructions are for\r\naccessing the \"bleeding edge\" branch, while all we want is the \"stable\" branch,\r\nwhich is the SVN trunk branch.\r\n\r\nOnce you have V8 downloaded, you can build it by following the [V8 building with\r\nGYP instructions](http://code.google.com/p/v8/wiki/BuildingWithGYP). Make sure\r\nyou note the bit about downloading the Chromium-provided Cygwin, as the Visual\r\nStudio build **will not work without it**.\r\n\r\nNote that if you're using a more recent version of Visual Studio (or is it just\r\nthe express versions?) you'll need to use `MSBuild` instead of `devenv` to build\r\nthe project from the command line. The command is similar:\r\n\r\n    MSBuild build/all.sln /p:Configuration=Release \r\n\r\nIf you're planning on building the debug version of the plugin, you'll want to\r\nuse `/p:Configuration=Debug` instead.\r\n\r\nOnce V8 is built, you should be able to build everything else using the\r\n`jsvsynth.sln`.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}